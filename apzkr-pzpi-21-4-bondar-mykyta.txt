Міністерство освіти і науки України
Харківський національний університет радіоелектроніки 
 
	 	 	 	 	Факультет комп’ютерних наук 
 
Кафедра програмної інженерії 
 
КУРСОВА РОБОТА 
ПОЯСНЮВАЛЬНА ЗАПИСКА 
з навчальної дисципліни «Архітектура програмного забезпечення» 
Тема роботи: «Програмна система для моніторингу екологічного стану місцевості» 

                                                   
Студент гр. ПЗПІ-21-4                            __________________Бондар М.С. 
	 	(підпис) 
Керівник роботи                                      __________________доц. Лещинська І.О. 
	 	(підпис) 
 
Роботу захищено «__»_________2024 р. 
з оцінкою _________________________ 
 
Комісія:                                                     __________________доц. Лещинський В.О. 
(підпис) 
                                                                   __________________доц. Лещинська І.О. 
(підпис) 
                                                                   __________________ст. викл. Сокорчук І.П.  (підпис) 
 
Харків  
2024 
Харківський національний університет радіоелектроніки 
 
Факультет комп’ютерних наук Кафедра програмної інженерії  
Спеціальність 121 – Інженерія програмного забезпечення 
Курс          3       Семестр                                         6                                                 _       
Навчальна дисципліна Архітектура програмного забезпечення            
 
ЗАВДАННЯ 
НА КУРСОВУ РОБОТУ СТУДЕНТОВІ 
 
                                           Бондар Микита Сергійович                                                  _ 
1.	Тема проєкту: Програмна система для моніторингу екологічного стану місцевості. 
2.	Термін узгодження завдання курсової роботи «06»    березня   2024 р. 
3.	Термін здачі студентом закінченої «30»    червня   2024 р. 
4.	Вихідні дані до проєкту (роботи): Система має бути унікальною і актуальною. Мати орієнтацію на масового користувача й можливість монетизації. Система має включати серверну і клієнтську частини, мобільний додаток та застосунок для IoT або смарт-пристроїв, а також забезпечувати безпеку даних і мати інструменти адміністрування.Система повинна бути розроблена за допомогою актуальних засобів розробки, які дозволяють ефективно виконувати поставлену задачу, а саме WebStorm для React, PyCharm для Django та Xcode для SwiftUI.  
5.	Зміст пояснювальної записки (перелік питань, що належить розробити): вступ, аналіз предметної області, постановка задачі, проектування програмного проекту, структура бази даних, код проекту, опис розробленої програмної системи, висновки, перелік інформаційних джерел, додатки.             
6.	 Перелік графічного матеріалу (діаграми, рисунки, інтерфейси): Діаграми, включаючи Deployment, Use Case, ER-модель, Interaction Overview, Activity, Component, Package та State Diagrams, використовуються для моделювання різних аспектів програмних систем та їх компонентів. Інтерфейси сторінок застоскунку. 


КАЛЕНДАРНИЙ ПЛАН 
  
  
№  	Назва етапу  	Термін виконання  	Примітка  
1  	Функціональна специфікація програмного проєкту 	28.02.2024  	 Виконано 
2  	Проектування програмного проєкту 	20.03.2024  	 Виконано 
3  	Кодування програмного проєкту 	04.05.2024  	 Виконано 
4  	Оформлення пояснювальної записки 	29.05.2024  	 Виконано 
5  	Захист курсової роботи 	30.06.2024  	 Виконано 
  
  
Дата видачі завдання «   06   »        березня           2024 р.    
  
  
	Керівник               	 	      	                  доц. Лещинська І.О.  
                                                                           
(підпис)   
  
Завдання прийняв до виконання   
ст. гр. ПЗПІ-21-4                                                      Бондар М.С. 
                                                                        
(підпис)  
 
 
 
 	 
РЕФЕРАТ 
 
 
Пояснювальна записка до курсової роботи: с. 81 , рис. 21  , табл. 3, додатки 5, джерел 5. 
ЕКОЛОГІЯ, ДОВКІЛЛЯ, МОНІТОРИНГ, АНАЛІТИКА, ЗАБРУДНЕННЯ, СТАН АТМОСФЕРИ, СИСТЕМА МОНІТОРИНГУ, ЗБІР ДАНИХ, СЕНСОРИ, УПРАВЛІННЯ ДАНИМИ. 
Об'єктом дослідження є системи моніторингу екологічного стану місцевості, які дозволяють виявляти та аналізувати рівні забруднення повітря, води та ґрунту. Розглядаються сучасні проблеми, пов'язані з впливом антропогенних факторів на довкілля та необхідність оперативного реагування на зміни в екологічній ситуації. 
Метою курсової роботи є розробка програмної системи для моніторингу екологічного стану місцевості, яка забезпечує автоматизований збір, обробку та аналіз даних про екологічні показники. Система дозволяє отримувати дані в режимі реального часу з різних сенсорів, що вимірюють рівень забруднення, та надає інструменти для їх візуалізації. Дані, отримані системою, можуть бути використані органами місцевого самоврядування, екологічними організаціями та компаніями для прийняття рішень щодо покращення екологічного стану регіону. 
Методологія курсової роботи включає розробку комплексної системи, яка інтегрує сенсори для збору даних, серверну частину для обробки інформації та веб-додаток та мобільний додаток для відображення результатів. Система забезпечує автоматичний збір даних з екологічних сенсорів, їх обробку та аналіз. 
Методи розробки серверної частини базуються на використанні мови програмування Python та фреймворку Django. База даних реалізована з використанням PostgreSQL. Для роботи з сенсорами використовується платформа Arduino та мікроконтролери з підтримкою IoT. Клієнтська частина створена за допомогою бібліотеки React, а мобільний додаток розроблений на SwiftUI для забезпечення доступу до даних у будь-який час. 
У результаті роботи було створено програмну систему для моніторингу екологічного стану місцевості. Ця система включає веб-додаток, мобільний додаток, серверну частину та IoT-пристрої для збору екологічних даних, що забезпечує комплексний підхід до відстеження стану довкілля та прийняття рішень щодо його покращення.. 
 
  
ЗМІСТ 
 
 
Вступ ................................................................................................................................ 7 
1	Аналіз та концептуальне моделювання предметної області 
1.1	Бізнес-вимоги .................................................................................................... 9 
1.1.1	Бізнес можливості ................................................................................. 9 
1.1.2	Бізнес-цілі та критерії успіху.............................................................. 10 
1.1.3	Потреби клієнтів або ринку ............................................................... 11 
1.1.4	Бізнес-ризики ...................................................................................... 12 
1.2	Концепція рішення .......................................................................................... 13 
1.2.1	Окреслення концепції ......................................................................... 13 
2.2.2	Головна функціональність ............................................................................ 14 
2.2.3	Припущення та залежності ........................................................................... 16 
1.3	Рамки та обмеження проєкту .......................................................................... 17 
1.3.1	Рамки первинного випуску ................................................................ 17 
1.3.2	Рамки наступних випусків ................................................................. 20 
1.3.3	Обмеження та винятки ........................................................................ 21 
1.4	Бізнес-контекст ................................................................................................ 22 
1.4.1	Профілі зацікавлених сторін .............................................................. 22 
1.4.2	Пріоритети проєкту ............................................................................ 24 1.4.3 Робоче середовище ...................................................................................... 25 2 Постановка задачі ................................................................................................ 29 
3	Проектування програмного забезпечення ................................................................ 31 
3.1	Проектування серверної частини проєкту ..................................................... 31 
3.2	Проектування клієнтської частини проєкту .................................................. 34 
3.3	Проектування мобільного додатка проєкту .................................................. 37 
4	Кодування програмного проєкту ............................................................................... 40 
4.1	Кодування серверної частини проєкту ........................................................... 40 
4.1.1	Реалізація методу для автоматичної генерації бекапів…………................... 43 
4.1.2	Реалізація методів створення локації пілся оплати........................................ 44 
4.1.3	Функція підрахунку індексу AQI………………............................................. 45 
4.2	Кодування клієнтської частини проєкту ........................................................ 46 
4.2.1	Розробка користувацького інтерфейсу ............................................................47 
4.3	Кодування мобільної частини проєкту .......................................................... 55 
4.3.1	Розробка мобільного інтерфейсу .................................................................... 56 
Висновки ..................................................................................................................... 60 Перелік джерел посилання .................................................................................... 62 Додаток А ....................................................................................................................... 63 Додаток Б ........................................................................................................................ 67 Додаток В ........................................................................................................................68
Додаток Г ........................................................................................................................69 Додаток Д ........................................................................................................................81 


ВСТУП
 
 
Сучасний стан довкілля потребує ефективних методів моніторингу та управління екологічними показниками, оскільки традиційні способи збору та обробки даних часто виявляються неефективними та застарілими. Це призводить до недостатньо оперативного реагування на екологічні зміни та виникнення серйозних проблем, пов'язаних із забрудненням навколишнього середовища. Люди часто не усвідомлюють рівня забруднення у своїй місцевості, що на перший погляд здається незначною проблемою, але може мати негативний вплив на здоров'я населення та стан довкілля. Без належної системи моніторингу важко вчасно виявити забруднення повітря, води або ґрунту, що може призвести до серйозних екологічних наслідків. 
Відсутність можливості легко отримувати актуальну інформацію про стан навколишнього середовища також є важливою проблемою, оскільки це може призводити до неправильного використання ресурсів, недосконалого планування заходів з охорони довкілля та загострення екологічних криз. Ці проблеми особливо актуальні для місцевих органів влади, екологічних організацій та громадян, які прагнуть зробити свій внесок у збереження довкілля. 
Для бізнесу, зокрема компаній, що займаються виробництвом і промисловістю, важливо мати доступ до точної інформації про екологічний стан місцевості, де розташовані їхні виробничі потужності. Відсутність такої інформації може призводити до невірних управлінських рішень та екологічних порушень, які можуть негативно вплинути на репутацію компанії та спричинити штрафні санкції з боку державних органів.
Система дозволяє здійснювати автоматизований збір даних про рівень забруднення повітря. Зберігаючи всі дані у системі, користувачі отримують швидкий та зручний доступ до аналітики, що допомагає вчасно виявляти потенційні проблеми та приймати необхідні заходи.
Система є простою у використанні, що дозволяє органам влади, екологічним організаціям та звичайним громадянам з будь-яким рівнем досвіду швидко освоїти її та застосовувати на практиці. Крім того, система надає детальну статистику про екологічні показники, що сприяє прийняттю обґрунтованих рішень щодо охорони довкілля та покращення екологічної ситуації в регіоні.   
1	АНАЛІЗ ТА КОНЦЕПТУАЛЬНЕ МОДЕЛЮВАННЯ ПРЕДМЕТНОЇ ОБЛАСТІ 
	1.1 	Бізнес-вимоги 
1.1.1 Бізнес можливості 
 
 
На сучасному ринку існують різні системи для екологічного моніторингу, які забезпечують базові функції з відстеження екологічного стану, проте жодна з них не пропонує комплексного рішення, яке б включало збір даних у реальному часі з різних джерел, інтеграцію з мобільними додатками для оперативного сповіщення користувачів, а також аналіз даних для прогнозування та прийняття рішень. 
Одним із відомих конкурентів є система Envirosuite[1], яка надає можливість моніторингу та аналізу екологічних показників у режимі реального часу. Проте, вона має обмеження у масштабованості та зручності використання для широкого кола користувачів, а також не підтримує інтеграцію з мобільними додатками для сповіщень чи персоналізованого аналізу даних. Розроблена система вирішує ці проблеми завдяки своїй унікальній функціональності. Вона забезпечує автоматизований збір даних про стан навколишнього середовища з різних сенсорів, підтримує інтеграцію з мобільними додатками для оперативного інформування користувачів про зміни екологічної ситуації та надає інструменти для глибокого аналізу та прогнозування екологічних тенденцій.
Таким чином, завдяки унікальному набору функцій, високій адаптивності до ринкових потреб та широкому спектру застосувань, розроблена система екологічного моніторингу має високий потенціал для розвитку та монетизації:

а) Платні підписки на програмне забезпечення – користувачі та бізнеси зможуть підписатися на додаткові функції, такі як глибший аналіз даних, персоналізовані сповіщення та інтеграція з іншими системами. 
б) Продаж обладнання та датчиків – система передбачає можливість продажу або лізингу сенсорів та іншого обладнання для моніторингу екологічного стану як приватним особам, так і компаніям.. 
в) Партнерські програми та інтеграції – система передбачає можливість інтеграції з іншими екологічними платформами, мобільними додатками та електронною комерцією для обміну трафіком та крос-промоції.
	
	 
1.1.2 Бізнес-цілі та критерії успіху 
 

BO-1: Система введена в експлуатацію і працює в кожному регіоні протягом 6 місяців після завершення розробки. 
SC-1:Експлуатація системи без серйозних помилок і збоїв отримання відгуків від користувачів про роботу системи. 
BO-2: Залучити не менше 1000 нових користувачів протягом одного року після впровадження системи. 
SC-2: Розширити використання системи і залучити нові державні установи, екологічні організації, підприємства місцевих жителів. 
BO-3: Підвищити точність і надійність даних, що надаються системою, до 95% протягом двох років після впровадження. 
SC-3:Регулярно оновлювати систему на основі відгуків користувачів для поліпшення якості даних, що надаються. 
BO-4: Збільшити кількість екологічних параметрів, що відстежуються системою, до 15 протягом трьох років після впровадження. 
SC-4: Розширення можливостей системи для моніторингу нових параметрів навколишнього середовища, таких як забруднення повітря дрібними частинками, рівень радіації. 

 
1.1.3 Потреби клієнтів або ринку 
 
 
Програмні системи для моніторингу екологічного стану мають стратегічне значення для різних категорій користувачів, включаючи державні органи, підприємства та мешканців регіонів. Основна мета таких систем полягає в наданні точних і актуальних даних про стан навколишнього середовища, що дозволяє ефективно приймати рішення та вчасно реагувати на потенційні загрози: 
а) Державні органи потребують інструментів для централізованого моніторингу, збору та аналізу даних з різних джерел, забезпечуючи при цьому високу точність і достовірність інформації. Важливим аспектом є здатність до інтеграції з іншими державними інформаційними системами та платформами для забезпечення узгодженості даних.
б) Підприємства використовують системи моніторингу для мінімізації впливу своєї діяльності на навколишнє середовище та дотримання екологічних стандартів. Вони потребують інструментів для оцінки ризиків, зниження екологічних витрат та забезпечення екологічної відповідальності. 
В) Мешканці регіонів також мають потребу в доступі до екологічної інформації для забезпечення власної безпеки та здоров'я. Їм необхідний зручний і зрозумілий інтерфейс, який дозволить швидко отримувати дані про стан навколишнього середовища, зокрема, про якість повітря. Важливою є функція отримання сповіщень у разі погіршення екологічної ситуації.

 
1.1.4 Бізнес-ризики 
 
 
У процесі реалізації нашого проєкту ми розглядаємо кілька ключових бізнес-ризиків, які можуть вплинути на його успішність. Давайте розглянемо кожен з цих ризиків більш детально: 

– Конкуренція на ринку: В галузі систем екологічного моніторингу існує висока конкуренція, і багато компаній вже пропонують аналогічні продукти. Попит на наші системи може знизитися, особливо якщо конкуренти запропонують аналогічні чи привабливіші рішення. Оцінка серйозності ризику: ризики серйозні через високий рівень конкуренції у галузі. 
– Терміни: розробка та використання системи може зайняти більше часу, ніж передбачалося спочатку. Це може бути пов'язано з низкою факторів, включаючи технічні труднощі, нестачу ресурсів та затримки у процесі розробки. Затягування термінів розробки може призвести до додаткових витрат та зниження ефективності проекту. Оцінка рівня ризику: Проект має чіткий графік та план розробки, тому ризик оцінюється як помірний, хоча можливі деякі затримки. 
– Прийнятність користувача: важливим чинником успіху проекту є прийнятність проекту кінцевого користувача. Якщо користувачі не будуть задоволені функціональністю, працездатністю та інтерфейсом системи моніторингу, попит на продукт може знизитись, і успіх на ринку може бути віддаленим. Оцінка ступеня ризику: Продукт був розроблений з урахуванням потреб та очікувань користувачів, тому ризик оцінюється як помірний.  
– Проблеми впровадження: у процесі розробки та впровадження системи можуть виникнути різні технічні проблеми, які можуть ускладнити використання системи. До них відносяться помилки у програмному забезпеченні, несумісність з іншими системами та проблеми інтеграції. Такі проблеми можуть знизити ефективність проекту та підірвати довіру користувачів. Оцінка ступеня ризику: У проекті працює команда досвідчених розробників та тестувальників, тому ризик оцінюється як помірний, але технічні проблеми завжди можливі та потребують уваги. 

 
	1.2 	Концепція рішення 
1.2.1 Окреслення концепції 
 
 
Програмна система для моніторингу екологічного стану ландшафтів дозволить широкому колу користувачів, включаючи державні органи з питань екології, місцеві органи самоврядування, природоохоронні організації, наукові установи, промислові підприємства та місцеві громади, отримувати актуальну та точну інформацію про стан довкілля.
Природоохоронні організації зможуть використовувати систему для моніторингу стану довкілля, що дозволить вчасно вживати заходи з охорони природи. Для промислових підприємств система стане інструментом, який допоможе знизити негативний вплив на довкілля, дотримуватися екологічних норм та покращити екологічну репутацію. Місцеві громади зможуть отримувати актуальну інформацію про стан довкілля у своєму регіоні, що сприятиме прийняттю обґрунтованих рішень для його захисту. 
Унікальними перевагами запропонованої системи є її висока масштабованість і гнучкість, що дозволяє адаптувати її до різних регіонів та екологічних умов. Система підтримує інтеграцію з мобільними додатками, що дозволяє користувачам отримувати сповіщення у реальному часі, а також забезпечує зручний інтерфейс, який легко освоїти навіть непідготовленим користувачам. Це дозволяє не тільки оперативно отримувати інформацію, але й прогнозувати екологічні зміни та вчасно реагувати на них, що робить цю систему привабливішою порівняно з іншими аналогічними рішеннями на ринку. 
 
 
2.2.2 Головна функціональність 
 
 
MF-1. Збір даних: Система забезпечує збір даних про стан навколишнього середовища через різноманітні датчики та пристрої. Зокрема, вона вимірює якість повітря, рівень вологості, температуру, забруднення води та ґрунту. Для реалізації цієї функції використовуються сучасні сенсори та технології, такі як оптичні датчики для вимірювання забруднень і сенсори вологості для моніторингу ґрунту. Основною метою є забезпечення постійного і точного збору даних для подальшого аналізу.
MF-2. Аналіз даних: Зібрані дані обробляються та аналізуються з використанням алгоритмів машинного навчання, таких як нейронні мережі та алгоритми кластеризації. Це дозволяє виявляти закономірності, тренди і аномалії в екологічних даних. Методи класифікації допомагають виявляти потенційні проблеми в стані довкілля та прогнозувати їх можливі наслідки.
MF-3. Подання даних: Інформація про стан довкілля подається у вигляді графіків, діаграм і карт, що спрощує її сприйняття. Система використовує візуалізаційні інструменти, такі як інтерактивні дашборди, для ефективного відображення даних. Це полегшує користувачам аналіз інформації та прийняття рішень. 
MF-4. Забезпечення точності та надійності даних: Система гарантує високу точність і надійність даних завдяки використанню висококласних датчиків і технологій збору даних, а також механізмів валідації. Це включає регулярну калібрування сенсорів та перевірку даних за допомогою вбудованих алгоритмів перевірки якості.
MF-5. Забезпечення безпеки даних: Дані захищені від несанкціонованого доступу та пошкоджень. Використовуються шифрування даних, автентифікація користувачів та контроль доступу для забезпечення конфіденційності і цілісності інформації. Система відповідає міжнародним стандартам безпеки даних, таким як GDPR.
MF-6. Надання інформації у зручній формі: Інформація про екологічний стан подається у зрозумілій формі з використанням графіків, таблиць і карт. Це включає інтерактивні візуалізації та адаптивні інтерфейси, які забезпечують просте розуміння даних.
MF-7. Розробка веб-інтерфейсу: Інтерфейс системи розроблений для роботи через веб-браузер, забезпечуючи інтуїтивно зрозуміле взаємодію з користувачем. Веб-інтерфейс включає функціонал для моніторингу даних в реальному часі та налаштування сповіщень.
MF-8. Сумісність із різними пристроями та платформами: Система сумісна з різними пристроями і операційними платформами, включаючи Windows, macOS, Android та iOS. Це забезпечує універсальність та доступність системи для всіх користувачів.
MF-9. Підтримка різних форматів даних: Система підтримує міжнародні стандарти інтероперабельності, що дозволяє їй ефективно працювати з різними форматами даних, такими як тексти, числа, дати, часи, графічні та мультимедійні файли.
MF-10. Інтеграція з іншими системами моніторингу: Система підтримує інтеграцію з іншими системами моніторингу через стандартизовані протоколи та API. Це дозволяє обмінюватися даними та розширювати функціональність системи, забезпечуючи більш комплексний підхід до екологічного моніторингу.
MF-11.Конкретизація функцій: Для кожної функції системи використовуються конкретні методи та технології. Наприклад, для аналізу даних застосовуються алгоритми класифікації, кластеризації та нейронні мережі.
MF-12.Посилання на стандарти: Система відповідає міжнародним стандартам екологічного моніторингу, таким як ISO 14000, що забезпечує високу якість і стандартизацію в роботі з екологічними даними.


2.2.3 Припущення та залежності 
 
 
Припущення: 
-	A-1. Припускається, що розробка проекту буде базуватися на сучасних 
технологіях та методологіях розробки програмного забезпечення. 
-	A-2. Припускається, що доступ до системи буде здійснюватися через 
веб-браузер. 
-	A-3. Припускається, що збір даних про стан навколишнього середовища 
буде проводитися за допомогою сенсорів та інших пристроїв збору інформації. 

Залежності: 
-	D-1. Проект залежить від наявності надійних постачальників сенсорів та 
обладнання для збору даних про стан навколишнього середовища. 
-	D-2. Успішність проекту також залежить від можливості інтеграції з існуючими системами моніторингу та управління, що вимагає співпраці з партнерами по розробці або сторонніми постачальниками програмного забезпечення. 
-	D-3. Проект також має залежність від доступності необхідних фінансових ресурсів для розробки, впровадження та підтримки системи моніторингу навколишнього середовища. 
 
 
	1.3 	Рамки та обмеження проєкту 
1.3.1 Рамки первинного випуску 
 
 
Серверна частина (Back End):
•	Управління користувачами: Реалізація реєстрації, авторизації, додавання та видалення користувачів, ролей і налаштувань доступу. Включає хешування паролів і контроль доступу на рівні API для забезпечення безпеки облікових записів.
•	Управління даними про стан навколишнього середовища: Збір, зберігання та обробка даних за допомогою сучасних технологій і алгоритмів, таких як машинне навчання та обробка великих даних. Використовуються алгоритми, наприклад, для кластеризації та класифікації даних.
•	Моніторинг та управління безпекою: Постійний нагляд за системою з метою виявлення та запобігання загрозам безпеці даних і інфраструктури. Включає системи моніторингу вторгнень і автоматичне реагування на підозрілі активності.
•	Інтеграція з іншими системами: Забезпечення можливості взаємодії та обміну даними з іншими системами моніторингу і управління, відповідно до стандартів обміну даними, таких як REST або GraphQL.
Клієнтська частина (Front End):
•	Графічний інтерфейс користувача (GUI): Розробка інтуїтивно зрозумілого інтерфейсу, що відповідає принципам дизайну та доступності, для зручної взаємодії з системою.
•	Візуалізація даних: Подання інформації у формі, карт та інших візуальних елементів. Включає можливості для зуму, фільтрації та інтерактивного аналізу даних.
•	Керування користувацькими обліковими записами: Реалізація реєстрації, входу в систему, а також двофакторної аутентифікації для підвищення безпеки.
•	Взаємодія з серверною частиною: Реалізація асинхронних механізмів для отримання та відображення даних, включаючи підтримку WebSocket для реального часу.
•	Мобільна сумісність: Забезпечення доступу через мобільні пристрої з підтримкою різних платформ (iOS, Android) як через веб-браузер, так і через мобільний додаток.
Smart Device:
•	Збір даних: Постійний моніторинг параметрів екологічного стану за допомогою вбудованих сенсорів, таких як оптичні сенсори для забруднення повітря. Технічні деталі сенсорів включають калібрування для забезпечення точності вимірювань.
•	Аналіз даних: Обробка даних з використанням алгоритмів для визначення відповідності нормам екологічної безпеки. Включає алгоритми для порівняння отриманих даних з встановленими стандартами.
•	Визначення відхилень: Виявлення відхилень від норм і їх класифікація за типом і серйозністю. Включає механізми корекції та повідомлення користувачів про критичні відхилення.
•	Генерація повідомлень: Автоматичне створення і відправка сповіщень про відхилення через різні канали комунікації, такі як мобільні сповіщення і електронна пошта.
Mobile:
•	Перегляд інформації про екологічний стан: Можливість переглядати дані про екологічний стан у зручному форматі. Включає функціонал для синхронізації даних та оновлень у реальному часі.
•	Сповіщення про відхилення: Отримання сповіщень про виявлені відхилення через мобільний додаток. Використання каналу пуш-повідомлень для своєчасного інформування.
•	Візуалізація даних: Можливість візуалізації даних у картах, з інтерактивними елементами для аналізу.
•	Доступність даних: Функціонал для поділу інформацією через соціальні мережі або з іншими користувачами.
•	Налаштування та споживчі відгуки: Можливість персоналізації повідомлень і надання зворотного зв'язку про якість даних та функціональність додатку.
Загальна функціональність:
•	Адміністрування користувачами: Додавання, редагування і видалення користувачів з різними ролями і правами доступу.
•	Адміністрування даними: Додавання, редагування та видалення даних про стан навколишнього середовища.
•	Захист даних: Шифрування даних та захист від несанкціонованого доступу, використання протоколу HTTPS для забезпечення конфіденційності і цілісності даних.
•	Аутентифікація і авторизація: Реалізація механізмів для авторизації та контролю доступу користувачів.
•	Мовна локалізація: Підтримка української та англійської локалізації.

 
1.3.2 Рамки наступних випусків 
 
 
1.	Розглянемо функціональність, яку планується реалізувати у майбутніх випусках програмної системи: 
•	Інтеграція геолокаційних служб для відображення актуальних даних про екологічний стан у реальному часі на мапі місцевості через мобільний додаток. 
•	Впровадження інтелектуальних систем для аналізу історичних даних про стан довкілля та інших факторів для передбачення майбутніх екологічних проблем і потреб місцевих громад. 
•	Розширення функціоналу для можливості користувачів ділитися отриманою інформацією про стан довкілля з іншими користувачами або через соціальні мережі з метою поширення свідомості про екологічні питання та залучення більшої аудиторії до участі в охороні природи. 
•	Розширення функціоналу для можливості користувачів підключатися до груп та спільно моніторити стан довкілля, обмінюватися даними та спільно розробляти стратегії з охорони природи через спеціалізовані форуми або інші комунікаційні засоби. 

 
1.3.3	Обмеження та винятки 
 
 
Обмеження: 
•	Обмеження обсягу даних: Система може бути обмежена обсягом даних, який вона може обробляти та зберігати, що може вплинути на її здатність моніторити великі масштаби місцевості. 
•	Сумісність зі смарт-пристроями: Деякі смарт-пристрої можуть бути несумісні з системою моніторингу через обмеження операційних систем або технічних характеристик, що може обмежити доступність системи для деяких користувачів. 
•	Доступність у віддалених регіонах: Доступність системи може бути обмеженою в окремих віддалених регіонах, де доступ до Інтернету обмежений або де відсутні сервери для обробки даних. 
Винятки: 
•	Недоступність мережі: У випадку відсутності зв'язку з мережею деякі функції системи, наприклад, передача даних на сервер, можуть бути тимчасово недоступними. 
•	Обмеження доступу: Існуючі обмеження доступу до даних або ресурсів можуть призвести до тимчасової недоступності для деяких користувачів. 
•	Виняткові ситуації: Технічні або програмні збої, а також непередбачені обставини можуть призвести до недоступності системи для користувачів. 


	1.4 	Бізнес-контекст 
1.4.1 Профілі зацікавлених сторін 
 
 
Таблиця 1.2 – Профілі зацікавлених сторін 
 

Зацікавлена сторона	
 Обмеження
	
Основні
інтереси
	
Ставлення
	
Основна
цінність

Бізнес-клієнти 
	Обмеження бюджету, обмежений час 
	Покращена продуктивніст ь, економія коштів, оптимізація бізнес- процесів 
	Позитивний, зацікавлений у ефективності та економічності 
	Покращена продуктивніст ь, економія коштів 

Цільова аудиторія 
	Потрібна технічна експертиза для налаштування та обслуговуванн я 
	Покращення моніторингу навколишньог о середовища, доступ до надійних даних 
	Позитивний, обурений екологічним впливом 
	Покращення моніторингу навколишньог о середовища, доступ до надійних даних 

Кінцеві користувачі 
	Проблеми з сумісністю з деякими пристроями, обмежена мережева підтримка 
	Можливість моніторити місцеві екологічні умови, зручність використання 
	Позитивний, зацікавлений у зручності використання 
	Можливість моніторити місцеві екологічні умови, зручність використання 

Замовник 
	Бюджетні обмеження 
	Вчасна реалізація проекту, відповідність вимогам 
	Очікує успішну реалізацію проекту в строк та бюджет 
	Успішна реалізація проекту, прибуток від інвестицій 

Виконавець 
	Терміни та ресурси 
	Завершення проекту в строк та належну якість 
	Очікує співпрацю зі замовником для успішної реалізації 
	Отримання прибутку від реалізованого проєкту 


1.4.2 Пріоритети проєкту 
 
 
Таблиця 1.3 – Пріоритети проєкту 
 
Показник 	Виконання (етапи) 	 
Обмеження 
(граничні обмеження) 	 
Ступінь свободи 
(допустимий діапазон) 
План робіт 	Перша версія проєкту буде доступна до 08.06.2024 
	Виконання проекту в поставлені сроки 
	Допустимо 
порушення дедалайну на 2 місяці 

Функціон альність 	Забезпечення роботи основних функцій в першому релізі 
	Обмеження часу на реалізацію функціональності 
	75% функцій мають бути виконані до першого релізу 

Якість  	Створити надійну та безпечну систему для користувачів 
	Система повинна відповідати вимогам щодо захисту персональних даних, встановлених законодавством 
	Збереження стандартів якості на 95% 

Персонал 	Активна співпраця між членами команди 
	6 Розробників 1 Бізнес аналітик 4 тестувальники 
	Допускається тимчасова втрата двух розробників 

 
 
	 	Продовження таблиці 1.3 
 
Показник 	
Виконання (етапи) 	 
Обмеження 
(граничні обмеження) 	 
Ступінь свободи 
(допустимий діапазон) 
Ціна 	Дотримання основного бюджету 
	550 тис дол. США 
	Допустиме перевищення бюджету на 15% 

 
 
1.4.3 Робоче середовище 
 
 
Backend:
•	Мова програмування: Python
Python обрано завдяки великій спільноті розробників і багатій екосистемі. Ця мова надає широкий вибір бібліотек для обробки даних, зокрема бібліотеки для аналізу екологічних даних, роботи з великими даними та машинного навчання. Python також забезпечує високу продуктивність у веб-розробці, що дозволяє легко інтегрувати різні сервіси та функціональність.
•	Фреймворк для веб-додатків: Django[2]
Django забезпечує швидку розробку веб-додатків завдяки вбудованому ORM (Object-Relational Mapping) для роботи з базами даних, адміністративному інтерфейсу для управління даними, та великій кількості вбудованих функцій, що спрощують створення складних веб-застосунків. Django також надає засоби для захисту даних і підтримує масштабованість, що дозволяє безпечно та ефективно управляти екологічними даними.
•	База даних: PostgreSQL[3]
PostgreSQL — це потужна реляційна система управління базами даних, яка забезпечує надійне зберігання даних та підтримку складних запитів. Вона відрізняється високою продуктивністю, можливістю масштабування та підтримкою складних типів даних, таких як геопросторові дані, що є важливим для проєкту, який працює з даними про стан навколишнього середовища. PostgreSQL також підтримує розширення і кастомізацію, що дозволяє ефективно реалізовувати специфічні потреби проєкту.
•	Фреймворк для API: FastAPI
FastAPI — сучасний фреймворк для створення RESTful API, який забезпечує високу продуктивність та підтримку асинхронних операцій, що особливо важливо при обробці даних у реальному часі. FastAPI автоматично генерує документацію для API, що полегшує роботу розробників і забезпечує інтеграцію з іншими системами. Використання асинхронних функцій допомагає знизити затримки при обробці великих обсягів даних про стан навколишнього середовища.
•	Безпека:
Для забезпечення високого рівня безпеки рекомендується використовувати JWT (JSON Web Tokens) для аутентифікації та авторизації користувачів у веб-додатку. Це забезпечить безпечний і масштабований підхід до управління доступом.

Frontend:
•	Мови: HTML, CSS та JavaScript
HTML використовується для структурування сторінок, CSS для стилізації, а JavaScript для створення інтерактивних елементів. Ці мови є стандартом у веб-розробці та забезпечують стабільну та ефективну роботу веб-додатків.
•	Фреймворк для JavaScript: React.js
React.js полегшує розробку інтерфейсу користувача за допомогою компоненто-орієнтованого підходу, що забезпечує повторне використання коду та ефективне управління станом програми. Це дозволяє створювати динамічні та чуйні інтерфейси, а також оптимізує продуктивність веб-додатка при роботі з великим обсягом даних.
•	Фреймворк для CSS: Bootstrap
Bootstrap надає готові компоненти та стилі, що спрощує розробку адаптивного дизайну, який добре виглядає на різних пристроях. Bootstrap також підтримує швидке створення макетів і забезпечує відповідність інтерфейсу користувача сучасним стандартам UI/UX.

Mobile:
•	Для iOS (iPhone та iPad): Swift
Swift — це сучасна мова програмування, розроблена Apple, яка забезпечує високу продуктивність та безпеку при створенні мобільних додатків. Використання Swift у поєднанні з Xcode 14.2 дозволяє розробникам створювати ефективні програми з високою інтеграцією з iOS-екосистемою. Особливо важливою є підтримка Swift при розробці додатків для моніторингу екологічного стану, оскільки вона забезпечує оптимізацію для роботи з великими обсягами даних і підтримку реального часу.
•	Автоматичне оновлення:
Для мобільних додатків впроваджується механізм автоматичного оновлення, щоб користувачі завжди мали доступ до останніх функцій і поліпшень, особливо у випадку важливих оновлень безпеки.


IoT-пристрої:
•	Оптимізація:
Враховуючи обмежені обчислювальні ресурси IoT-пристроїв, використання легких бібліотек і фреймворків, таких як MicroPython або NodeMCU, є оптимальним вибором. Це дозволяє ефективно використовувати пристрої з обмеженими ресурсами для збору та обробки екологічних даних.

 
2	ПОСТАНОВКА ЗАДАЧІ 
 
 
Програмна система для моніторингу екологічного стану та аналітики Environmental Monitoring Analytics повинна підтримувати наступний функціонал:
-	Реєстрація, вхід та вихід з системи. Забезпечення процесу створення облікового запису новими користувачами шляхом введення основної інформації (ім'я, прізвище, номер телефону, електронна пошта, пароль). Можливість входу в систему для вже зареєстрованих користувачів з використанням електронної пошти та пароля.
-	Користувацький профіль. Надання користувачам можливості редагувати та переглядати свою особисту інформацію, таку як: ім'я, електронна пошта та пароль.
-	Перегляд, створення, редагування та видалення локацій. Надання користувачам можливості керувати інформацією про різні локації для моніторингу екологічного стану. Користувачі можуть додавати нові локації, наприклад, райони, міста або конкретні об'єкти, де проводиться моніторинг. Вони можуть редагувати існуючі локації, змінюючи їх назву, географічні координати або інші деталі. Також доступний функціонал для перегляду всіх створених локацій з можливістю видалення тих, що більше не використовуються для моніторингу.
-	Пуш-сповіщення.
Надання можливості створення тригерів для певних екологічних параметрів. Наприклад, користувач може налаштувати сповіщення, яке повідомлятиме його у разі перевищення допустимого рівня забруднення повітря чи води. Сповіщення мають надходити на мобільний пристрій користувача та веб додаток.
-	Перегляд інформації про екологічні параметри. Надання детальної інформації про певний екологічний параметр, включаючи назву, опис
-	Адміністративний функціонал. Можливість адміністратору переглядати дані користувачів, змінювати ролі, блокувати та розблоковувати облікові записи, а також видаляти профілі з системи. Адміністратори мають доступ до всіх таблиць даних у системі, з можливістю створення, редагування та видалення записів. Також адміністратор може створювати резервні копії баз даних та забезпечувати їх відновлення.
-	Підтримка англійської та української мови. Надання можливості вибору мови для користувачів, що забезпечує доступність системи для ширшої аудиторії.

 	  
3	ПРОЕКТУВАННЯ ПРОГРАМНОГО ПРОЄКТУ 
3.1 Проектування серверної частини проєкту 
 
Перед проєктуванням БД у системі PostgreSQL, була розроблена ER- модель даних (див. додаток. Б, рис. 1.Б): 
ER-модель містить наступні таблиці: 
–  «Користувач» – містить дані про користувачів; 
–  «Локація» – містить дані про локацію що надглядається; 
–  «Типи локацій» – містить всі можливі типи локацій; 
–  «Повідомлення» – містить дані про повідомлення; 
–  «Параметри» – містить дані про параметри; 
–  «Дані моніторингу» – містить дані моніторингу; 
    Між сутностями були встановлені наступні звʼязки: 
–  користувач – локації (1:М); 
–  типи локацій – локації (1:М); 
–  локації – дані моніторингу (1:М); 
–  параметри – дані моніторингу (1:М); 
–  локації – повідомлення (1:М); 
Після того, як всі сутності визначені, слід перейти до визначення основних сценаріїв використання програмної системи.
Для розроблюваної системи було створено діаграму прецедентів (див. додаток. В, рис. 1.В). 
Діаграма має два актори за ролями: адміністратор та користувач.
1. Адміністратор може виконувати наступні дії в додатку: – Автентифікація;
– Переглядати дані;
– Створення бекапів бази даних; 
– Редагування даних у базі даних для усіх користувачів. 
– Додавати нових адміністраторів.
– Переглядати локації усіх користувачів.
– Видаляти локації вибраних користувачів. 
2. Користувач може виконувати наступні дії в додатку: 
– Автентифікація;
– Створити власний акаунт;
– Змінити локалізацію; 
– Перегляд локацій;
– Додавання та редагування локацій;
– Перегляд сповіщень;
– Моніторинг умов навколишнього середовища. 
– Проводити оплату 

Для розроблюваної системи було створено діаграму розгортання(див. рис. 3.1), яка відображає архітектуру системи та взаємодію між різними компонентами. Діаграма ілюструє розміщення серверної частини, бази даних, клієнтських додатків, а також IoT-пристроїв для збору даних. Вона дозволяє чітко побачити, як різні елементи системи пов'язані між собою і які мережеві з'єднання використовуються для обміну даними. 
1.	Система складається з п’яти компонентів:
– База даних: Використовується як сховище для зберігання даних, пов’язаних з системою.
– Веб-сервер: Виконує функцію обробки запитів, що надходять від користувачів через веб-застосунок та мобільний застосунок.
– IoT пристрій: Використовується як емулятор IoT пристрою, збирає дані про хімічний склад повітря з вбудованих сенсорів. Ці сенсори регулярно вимірюють значення цих параметрів і передають їх до смарт-пристрою. 
– Веб-застосунок: Дозволяє користувачам взаємодіяти з системою за допомогою веб-інтерфейсу. 
– Мобільний застосунок: Забезпечує користувачам доступ до системи через мобільні пристрої. 

 
Рисунок 3.1 – UML діаграма розгортання 
  

	3.2 	Проектування клієнтської частини проєкту 
 
 
Для кращого розуміння взаємодії між користувачами та системою, було розроблено UML діаграму прецедентів (див. рис. В.1 у додатку В), у якій присутні два актори: адміністратор та користувач. Всі актори отримали функціонал, відповідно до їхніх ролей у системі.
Адміністратор може виконувати такі дії: автентифікація, перегляд даних, створення бекапів бази даних, редагування даних у базі даних для всіх користувачів, додавання нових адміністраторів, перегляд локацій усіх користувачів, видалення локацій вибраних користувачів.
Користувач має можливість автентифікації, створення власного акаунта, змінення локалізації, перегляду та редагування локацій, перегляду сповіщень, моніторингу умов навколишнього середовища, а також проведення оплат.
Паралельно з діаграмою прецедентів, для структурної організації системи була створена діаграма пакетів (див. рис. 3.2). Вона ілюструє, як різноманітні модулі, класи та компоненти об'єднуються в логічні пакети, що показує взаємозв'язки між ними. Ця діаграма допомагає візуалізувати архітектуру системи, підкреслюючи залежності та використання пакетів, що сприяє розумінню внутрішньої організації системи та її компонентів у контексті реалізації визначених сценаріїв використання.
 
Рисунок 3.2 – UML діаграма пакетів 
 
Після того, як основні сценарії використання системи були визначені та деталізовані у вигляді діаграми прецедентів, важливо розглянути, як саме користувачі взаємодіють із системою на рівні окремих операцій. Для цього було розроблено діаграму діяльності користувача.
Діаграма діяльності допомагає детально описати послідовність дій, які виконує користувач під час взаємодії із системою. Вона відображає кожен крок, починаючи від автентифікації до управління локаціями та отримання сповіщень, забезпечуючи наочне уявлення про потоки виконання дій в системі. Це дозволяє краще зрозуміти внутрішню логіку процесів і взаємозв'язок між різними етапами роботи з системою(див. рис. 3.3)
 

Рисунок 3.3 – UML діаграма діяльності. 
 

	3.3 	Проектування мобільного додатка проєкту 
 
 
Після визначення всіх сутностей наступним кроком є визначення основних сценаріїв використання програмної системи. Для цього найкраще підходить UML діаграма прецедентів, яка наочно відображає взаємодію користувачів із системою. Усі актори отримали функціонал, визначений у клієнтській частині, що дозволяє чітко зрозуміти їхні ролі та можливості в системі.
Далі слід перейти до розробки діаграми компонентів. Ця діаграма показує, як система розподілена на компоненти та як ці компоненти взаємодіють між собою. На рисунку нижче (див. рис. 3.4) відображено компоненти мобільного додатка системи, включно зі сторінками та їх взаємозв'язками.
Головним компонентом є панель управління. Вона надає користувачеві доступ до різноманітних функцій системи. Панель управління дозволяє переглядати та додавати локації, переглядати повідомлення, а також налаштовувати профіль.
Сторінка «Локації» відображає всі додані локації користувача і включає редагування, видалення та перегляд данних локації.. 
Сторінка «Додавання локації» переводить користувача на сторінку оплати. Якщо оплата успішна то користувач має можливість додати нову локацію.
«Налаштування профілю» дає можливість користувачу змінити особисті данні або вийти з системи.
«Повідомлення» надає відображення повідомлень користувачу у разі перевищення параметру однієї з локацій.
 
Рисунок 3.4 – Діаграма компонентів мобільного додатка системи. 
 
Після визначення компонентів стає можливим спланувати, як користувачі будуть взаємодіяти з мобільним додатком. Для цього була створена діаграма діяльності користувача (див. рис. 3.5). Діаграма схожа з клієнтською частиною, але додана можливість отримувати сповіщення.



 
Рисунок 3.5 – Діаграма діяльності мобільного додатку для користувача.

 
4	КОДУВАННЯ ПРОГРАМНОГО ПРОЄКТУ 
4.1 Кодування серверної частини проєкту 
 	 
 	 
Технології були обрані для написання серверної частини на основі функціональних потреб системи. Тому для написання серверної частини була обрана платформа Django з використанням Django REST Framework (DRF). Специфікація REST орієнтована на використання архітектурного стилю, який підкреслює використання ресурсів та їх ідентифікацію за допомогою URI. У Django були використані класи представлень (Views) для створення RESTful веб-сервісів, які взаємодіють за принципами архітектурного стилю REST.
Як база даних була використана реляційна база даних PostgreSQL, оскільки вона забезпечує надійність, ефективність у роботі з великими обсягами даних та підтримує складні SQL-запити. PostgreSQL дозволяє легко масштабувати систему, забезпечуючи швидкий доступ до інформації та стабільність роботи додатку. Серверна частина взаємодіє з базою даних завдяки ORM Django, що забезпечує зручну роботу з моделями та сутностями бази даних.
Для забезпечення безпеки та аутентифікації користувачів у додатку використовується JWT (JSON Web Token) авторизація. Цей метод аутентифікації дозволяє створювати токени, які містять інформацію про користувача та його права доступу. Токени зберігаються на клієнтській стороні та передаються з кожним запитом до серверної частини, що дозволяє уникнути необхідності постійної перевірки даних користувача на сервері. Це забезпечує високий рівень безпеки та покращує продуктивність системи.
Додаток використовує архітектуру MVC (Model-View-Controller). Суть архітектури полягає в тому, щоб організувати код таким чином, щоб забезпечити високий рівень абстракції та легкість у тестуванні. Додаток має такі шари:
•	Шар Model, в якому зберігаються основні сутності та логіка роботи з даними;
•	Шар View, що відповідає за відображення інформації та обробку запитів;
•	Шар Controller, який реалізує бізнес-логіку та управляє взаємодією між моделями та представленнями (Views).

Специфікація REST API наведена в таблиці 1 нижче. 
Таблиця 1 – REST специфікація
Модель	Метод	Адреса	Тіло запиту
User	POST	/api/v1/users/	first_name, last_name username, email, password, gender, birth_date
	POST	/api/v1/token/	username, password
	DELETE	/api/v1/users/	_id
	PATCH	/api/v1/users/	first_name, last_name username, email, new_password, confirm_new_password
	GET	api/v1/users/current_user/	_i
Locations	GET	/api/v1/locations/	-
	POST	/api/v1/locations/	name, description, country,city,location_type
	PUTCH	/api/v1/locations/	_id, name, description, city, country 

Продовження таблиці 1
Модель	Метод	Адреса	Тіло запиту
Locations	DELETE	api/v1/locations/	_id
	POST	api/v1/payment/	-
	GET	api/v1/locations-data	_id
	GET	api/v1/location-notifications/	_id
	DELETE	api/v1/location-notifications/	_id
Admin	GET	api/v1/users/	-
	POST	api/v1/token/	Username, password
	DELETE	api/v1/users/	_id
	PATCH	/api/v1/users/	_id, username, first_name, last_name, email, password
	POST	api/v1/users/id/set_staff/	_id
	POST	api/v1/users/id/set_superuser/
	_id
	GET	api/v1/locations/	-
	DELETE	api/v1/locations/	_id
	POST	api/v1/backup/	-
 
 

 
4.1.1 Реалізація методу для автоматичної генерації бекапів 
 
 
Функція для резервного копіювання бази даних, названа db_backup, відповідає за створення резервних копій бази даних PostgreSQL. Вона використовує модуль subprocess для виклику інструменту pg_dump, який експортує дані бази в SQL-файл. Функція спочатку формує ім'я файлу для бекапу, використовуючи поточну дату і час, щоб уникнути перезапису попередніх копій. Файл бекапу зберігається в папці backup з унікальним іменем, що містить дату та час. Функція запускає pg_dump для бази даних з назвою ecosystem і записує результати в зазначений файл. Якщо процес створення резервної копії проходить успішно, виводиться повідомлення про успіх. У разі помилки під час виконання pg_dump помилка буде відображена в повідомленні.
Для автоматичного запуску цієї функції з певною періодичністю використовується планувальник завдань BackgroundScheduler з бібліотеки apscheduler. У функції start створюється екземпляр планувальника, до якого додається зберігач завдань DjangoJobStore, що дозволяє зберігати інформацію про завдання в базі даних Django. Потім налаштовується завдання для виконання функції db_backup кожні три години. Планувальник запускається, і виводиться повідомлення про те, що він розпочав свою роботу. Це забезпечує регулярне створення резервних копій бази даних без потреби в ручному втручанні.
Код функції наведений у додатку А.1
 
 
4.1.2 Реалізація методів створення локації після оплати 
 
 
Ці  методи забезпечуют процес створення нових локацій у системі після успішного завершення оплати через платіжну систему Stripe.
Клас GeneratePaymentKeyAPI відповідає за генерацію унікального платіжного ключа та створення сесії для оплати. Коли користувач відправляє запит на створення платіжного ключа, система генерує новий унікальний ключ у форматі UUID, який додається до списку платіжних ключів користувача. Якщо у користувача ще не існує списку платіжних ключів, він ініціалізується як порожній список. Після цього ключ зберігається у профілі користувача. Для оплати через Stripe створюється нова сесія, яка включає інформацію про товар, його вартість, валюту та URL-адреси для успішної та неуспішної оплати. URL сесії повертається як частина відповіді, що дозволяє користувачу перейти на сторінку Stripe для завершення процесу оплати.
Клас LocationViewSet реалізує функціональність для створення нових локацій. Він перевіряє наявність платіжного ключа у запиті. Якщо ключ не надано або вже був використаний, повертається повідомлення про помилку. Якщо ключ дійсний і не використовувався раніше, він зберігається у профілі користувача. Потім система перевіряє дані для створення нової локації, і якщо дані валідні, створюється новий запис у базі даних з прив'язкою до користувача, який надав платіжний ключ. Метод perform_create зберігає нову локацію у базі даних, додавши інформацію про користувача, що створює локацію. Таким чином, нові локації можуть бути створені тільки після того, як користувач сплатить через Stripe, що забезпечує контроль за процесом платежів і уникнення створення локацій без попередньої оплати.
Код функції наведений у додатку А.2


4.1.3 Функція підрахунку індексу AQI 
 
 
Підрахунок AQI (Air Quality Index, індекс якості повітря) у цьому коді здійснюється шляхом агрегації даних моніторингу для кожної локації.
Процес підрахунку AQI розпочинається у методі list класу LocationMonitoringDataView. Коли користувач надсилає запит до цього методу, система спочатку отримує ідентифікатор локації (location_id) з параметрів запиту. Якщо ідентифікатор вказано, система фільтрує локації, вибираючи тільки ті, які відповідають зазначеному location_id і належать поточному користувачеві. Якщо ідентифікатор не вказано, система повертає всі локації, які належать користувачу.
Для кожної локації, яка відповідає запиту, система отримує всі дані моніторингу, що пов'язані з цією локацією, за допомогою фільтрації моделі MonitoringData за полем location. Дані моніторингу серіалізуються в формат JSON за допомогою MonitoringDataSerializer.
Після серіалізації даних система обчислює значення AQI. Це здійснюється шляхом сумування продукції ваги параметра (item['parameter']['weight']) і його значення (item['value']) для кожного з серіалізованих записів даних моніторингу. Вага параметра визначає важливість кожного параметра для загального індексу якості повітря, а значення - фактичне виміряне значення параметра. Сумарна величина цього добутку для всіх параметрів моніторингу надає значення AQI для відповідної локації.
Зібрані дані включають ідентифікатор локації, серіалізовані дані моніторингу і розраховане значення AQI, які відправляються у відповіді на запит. Таким чином, AQI розраховується як зважена сума значень моніторингових параметрів, що відображає загальний рівень забруднення повітря для кожної локації.
Реалізацію функції можна знайти в додатку А.3


	4.2 	 Кодування клієнтської частини проєкту 
 
 
Для реалізації клієнтської частини було вибрано React. React фокусується на створенні реактивних інтерфейсів користувача, дозволяючи розробникам будувати складні UI-компоненти та ефективно управляти їх станом. Це забезпечує високу продуктивність та зручність у розробці інтерфейсів.
Для роботи з HTTP-запитами використовується бібліотека Axios. Axios спрощує процес здійснення запитів до серверів, обробки відповідей і управління помилками, забезпечуючи зручний і ефективний спосіб комунікації між клієнтом і сервером.
Для обробки платіжних транзакцій інтегровано Stripe. Stripe надає потужний API для управління платежами, що дозволяє легко реалізувати платіжні форми та обробку платежів у додатку, забезпечуючи безпеку та зручність для користувачів.
Для локалізації додатку використовується бібліотека i18next. i18next є потужним інструментом для управління багатомовним контентом, пропонуючи гнучке та ефективне управління перекладами. Вона підтримує динамічну зміну мов у реальному часі, що дозволяє користувачам легко перемикати мови без перезавантаження сторінки. i18next також спрощує процес організації перекладів у окремі файли чи ресурси, що робить локалізацію більш упорядкованою та зручною для підтримки.
Для стилізації інтерфейсу використовуються компоненти з бібліотеки Bootstrap. Bootstrap надає готові стилі та компоненти, що спрощують розробку адаптивного та сучасного дизайну, покращуючи зовнішній вигляд додатку і забезпечуючи зручність для кінцевих користувачів

 
4.3.1 Розробка користувацького інтерфейсу  
 
 	 
 Першим кроком користувач має зареєструватися. На сторінці реєстрації(див Г.1 у додатку Г). користувач має ввести дані як на рисунку 4.1
 
Рисунок 4.1 – Реєстрація

 Після успішної реєстрації користувача зустрічає дашборд (див. рис. 4.2), де можна переглянути існуючі локації користувача та додати нові.
 
Рисунок 4.2 – Панель управління користувача. 
 
 	Натиснувши на локацію можна спостерігати за зібраними даними з повітря як на рисунку 4.3. 
 
Рисунок 4.3 – Параметри повітря видраної локації

Можна побачити два фонові кольори параметрів. Красний позначає що цей показник перевищено, зелений – показники у нормі.
Для того щоб створити нову локацію треба заплатити 5$ (див. рис 4.4). Після погодження користувача буде направлено на сторінку Stripe (див. рис 4.5) де вводяться данні картки. Після успішної оплати користувача буде попаде на сторінку зі створенням нової локації (див. рис 4.6).  Потім локація буде додана до списку усіх локацій користувача. 





 
Рисунок 4.4 – Повідомлення про необхідну оплату
 
Рисунок 4.5 – Сторінка Stripe
 
Рисунок 4.6 – Форма додавання нової локації
Код сторінки додавання локації наведений у додатку Г, Г2
	Також на сторінці дашборду корстивач може переглядати сповіщення з локацій які зʼявляются у разі превищеення якогь с показників(див. рис. 4.7)





 
Рисунок 4.7 – Сповіщення користувача

Якщо користувач захоче змінити свої данні просто змінивши значення поля він може це зробити на сторінці профілю як на рисунку 4.8. Після натискання кнопки “Save changes” данні користувача оновляться. Також за необхідністю пропонується змінити пароль.

 
Рисунок 4.8 – Сторінка профілю користувача
Якщо користувач є адміністратором, він має розширені права для управління системою. Адміністратор може переглядати інформацію про всіх користувачів системи, а також доступ до даних про всі локації. Це дозволяє йому мати повний огляд активностей та даних у системі (див. рис 4.9).




 
Рисунок 4.9 – Панель управління адміністратора
Адміністратор також має можливість видаляти або редагувати будь-які записи про користувачів та локації.
Крім того, адміністратор має право додавати користувачів до категорії адміністраторів. Це дозволяє розширювати команду управління, надаючи певним користувачам привілеї адміністратора, що може бути корисно для делегування відповідальності та розподілу навантаження між декількома адміністраторами.
На сторінці панелі управління адміністратор може також створювати резервні копії бази даних (див. рис. 4.10). Це важлива функція для забезпечення безпеки даних, яка дозволяє зберігати їх у разі збоїв або інших непередбачених ситуацій. Створення резервних копій є критично важливим для підтримки стабільності та цілісності системи, а адміністратор має доступ до цієї функції для забезпечення безперервності роботи.
 
Рисунок 4.10 – Повідомлення про створений бекап

Код панелі управління адміністратора наведений у додатку Г, Г3


4.3  Кодування мобільної частини проєкту 
 
 
Для розробки мобільного додатку основою вибору стала мова програмування Swift і її сучасний фреймворк SwiftUI[4]. SwiftUI є декларативним фреймворком для розробки графічних інтерфейсів у Swift, що спрощує створення складних інтерфейсів користувача завдяки декларативному підходу до опису UI-компонентів. Це дозволяє значно зменшити кількість коду та підвищити його читабельність.
Codable, що дозволяє ефективно перетворювати JSON у Swift-об'єкти та навпаки.
Для розробки інтерфейсу користувача у SwiftUI використовуються компоненти, які автоматично управляються системою на основі MVVM-архітектури (Model-View-ViewModel). MVVM сприяє розділенню логіки програми та її відображення, що спрощує управління станом додатку та тестування компонентів. Model відповідає за дані і бізнес-логіку, View відповідає за інтерфейс користувача, а ViewModel є посередником між Model і View, обробляючи дані та бізнес-логіку.
Для реалізації функціональності платежів був інтегрований сервіс Stripe. Stripe є потужною платформою для обробки платежів, що надає простий спосіб інтеграції платіжних функцій у мобільний додаток. Він підтримує різноманітні методи оплати та забезпечує безпечний обробіток платіжних транзакцій. 
 
 
4.3.1 Розробка мобільного інтерфейсу  
 
	 
 
Першим нас зустрічає екран з пропозицією увійти або зареєструватися(див. рис. 4.11). 

     

Рисунок 4.11 – Початковий екран мобільного додатку 
На сторінці панелі управління користувач має можливість переглядати список усіх локацій, а також отримувати сповіщення про важливі події. Якщо є нові повідомлення, то поруч з іконкою дзвоника з'являється червоний кружечок, що сигналізує про їх наявність.
Крім того, користувач може детально переглядати дані про локації в режимі реального часу. Якщо параметри відображаються зеленим кольором, це означає, що все в порядку. Якщо ж параметри підсвічуються червоним, це свідчить про перевищення допустимих рівнів, що потребує уваги. Весь описаний функціонал можна побачити на рисунку 4.12

   

Рисунок 4.12 – Можливості користувача на панелі управління

На вкладці "Додати локацію" користувачам пропонується сплатити 5 доларів за додавання кожної нової локації. Коли користувач погоджується з умовами сплати, він перенаправляється на екран для введення платіжних даних. Тут необхідно ввести реквізити платіжної картки, такі як номер картки, термін дії та CVV-код. Після введення платіжних даних система обробляє платіж і перевіряє його на коректність. У разі успішної оплати користувач отримує підтвердження про успішну транзакцію та автоматично переходить до форми додавання нової локації. На цьому етапі користувач може ввести всі необхідні деталі локації. Після заповнення всіх полів і підтвердження введених даних нова локація буде додана до системи. Описаний функціонал наведений на рисунку 4.13
     

Рисунок 4.13 – Додавання локації

Якщо користувач хоче змінити свої особисті дані або вийти з системи, він може зробити це у вкладці "Налаштування". У цій вкладці користувач знайде опції для редагування особистої інформації, такої як ім'я, електронна адреса та пароль. Для внесення змін користувачеві потрібно ввести нові дані у відповідні поля та підтвердити зміни, натиснувши кнопку "Зберегти"(див. рис. 4.14). 

  

Рисунок 4.14 – Налаштування профілю користувача


ВИСНОВКИ 
 
 
У ході виконання курсового проєкту було проведено всебічне концептуальне моделювання та детальний аналіз предметної області. На основі цього аналізу було розроблено комплексну програмну систему, яка підвищує ефективність збору та обробки даних з екологічних сенсорів і надає користувачам цінні інструменти для моніторингу навколишнього середовища.
Розробка включала створення концептуальної моделі предметної області, що дозволило глибше зрозуміти потреби користувачів і визначити основні вимоги до системи. Було здійснено проектування фізичної моделі даних та реалізацію системи з використанням сучасних технологій програмування. Зокрема, серверна частина була реалізована на платформі Python із застосуванням DRF для створення RESTful веб-сервісів. База даних була реалізована на PostgreSQL, що забезпечує високу продуктивність та надійність зберігання даних. Для клієнтської частини використовувалися HTML, CSS, JavaScript, а також React.js для створення динамічних інтерфейсів. Мобільний додаток було розроблено на мові програмування Swift із використанням фреймворку SwiftUI для iOS. SwiftUI надає сучасний підхід до створення інтерфейсів, дозволяючи створювати чуйні та адаптивні інтерфейси з меншим кодом. Завдяки декларативному стилю програмування, SwiftUI спрощує процес розробки, забезпечуючи гнучкість у створенні складних інтерфейсів і підтримуючи інтеграцію з іншими компонентами системи.
У процесі розробки додатку я також удосконалив свої навички побудови архітектури системи, використовуючи шаблони MVC та MVVM. Ці підходи дозволили структурувати код ефективніше, розділяючи логіку додатку та користувацький інтерфейс, що сприяло кращій підтримуваності та розширюваності системи.
У результаті роботи була створена та протестована програмна система, яка надає користувачам інструменти для моніторингу та аналізу екологічних даних у реальному часі. Система забезпечує зручність доступу до інформації, організацію та обробку даних із сенсорів. Вона також дозволяє створювати тригерні пуш-сповіщення, які інформують користувачів про зміну екологічних умов.


 
ПЕРЕЛІК ДЖЕРЕЛ ПОСИЛАННЯ 
 
 
1.	Документація Envirosuite. Офіційний ресурс про Envirosuite URL: https://envirosuite.com/solutions/environmental-management  (дата звернення 11.08.24) 
2.	Документація Django 	URL: 
https://docs.djangoproject.com/en/stable/ (дата звернення 12.08.24) 
3.	Документація PostgreSQL URL: https://www.postgresql.org/docs/ (дата звернення 12.08.24) 
4.	Документація SwiftUI URL: https://developer.apple.com/xcode/swiftui/ (дата звернення 18.08.24) 
5.	Функціональне тестування розробленого функціоналу для системи. URL: https://www.youtube.com/watch?v=ssH3UjXBRwI
 
 
ДОДАТОК А 
Код серверної частини 
 А.1 Реалізація методу для автоматичної генерації бекапів
 
 
1. def db_backup():
2.     with contextlib.suppress(Exception):
3.         try:
4.             now = datetime.now().strftime('%Y-%m-%d_%H-%M-%S')
5.             backup_file = f'backup/auto_backup_{now}.sql'
6.             pg_dump_path = '/opt/homebrew/opt/postgresql@16/bin/pg_dump'
7.             with open(backup_file, 'w') as f:
8.                 result = subprocess.run(
9.                     [pg_dump_path, 'ecosystem'],
10.                     stdout=f,
11.                     stderr=subprocess.PIPE,
12.                     check=True
13.                 )
14.             print("Backup created successfully! File: " + backup_file)
15.         except subprocess.CalledProcessError as e:
16.             print("Failed to create backup: " + e.stderr.decode())
17. 
18. def start():
19.     scheduler = BackgroundScheduler()
20.     scheduler.add_jobstore(DjangoJobStore(), "default")
21.     scheduler.add_job(db_backup, 'interval', hours=3, jobstore="default", id="weekly_backup", replace_existing=True)
22.     scheduler.start()
23.     print('Start scheduler')



 
 
 А.2 Методи створення локації після оплати 

1. class GeneratePaymentKeyAPI(viewsets.ViewSet):
2.     queryset = Location.objects.all()
3.     permission_classes = [permissions.IsAuthenticated]
4.     def create(self, request):
5.         user = request.user
6.         payment_key = str(uuid.uuid4())
7.         if user.all_payment_keys is None:
8.             user.all_payment_keys = []
9.         user.all_payment_keys.append(payment_key)
10.         user.save()
11.         payment_intent = stripe.checkout.Session.create(
12.             payment_method_types=['card'],
13.             line_items=[{
14.                 'price_data': {
15.                     'currency': 'usd',
16.                     'product_data': {
17.                         'name': 'Location Creation Fee',
18.                     },
19.                     'unit_amount': 500,
20.                 },
21.                 'quantity': 1,
22.             }],
23.             mode='payment',
24.             success_url=('http://localhost:3000/addLocation?') + payment_key,
25.             cancel_url=request.build_absolute_uri('/cancel/'),
26.             client_reference_id=request.user.id
27.         )
28.         return Response({'payment_url': payment_intent.url}, status=status.HTTP_200_OK)
29. 
30. class LocationViewSet(viewsets.ModelViewSet):
31.     queryset = Location.objects.all()
32.     serializer_class = LocationSerializer
33.     permission_classes = [permissions.IsAuthenticated]
34. 
35.     def get_queryset(self):
36.         if self.request.user.is_staff:
37.             return Location.objects.all()
38.         else:
39.             return Location.objects.filter(user=self.request.user)
40. 
41.     def create(self, request, *args, **kwargs):
42.         payment_key = request.data.get('payment_key')
43.         if not payment_key:
44.              return Response("Payment key is required.")
45.         user = request.user
46.         if payment_key == user.payment_key or (payment_key not in user.all_payment_keys):
47.              return Response("Payment key has already been used.")
48. 
49.         user.payment_key = payment_key
50.         user.save()
51.         serializer = self.get_serializer(data=request.data)
52.         serializer.is_valid(raise_exception=True)
53.         self.perform_create(serializer)
54.         headers = self.get_success_headers(serializer.data)
55.         return Response(serializer.data, status=status.HTTP_201_CREATED, headers=headers)
56. 
57.     def perform_create(self, serializer):
58.         serializer.save(user=self.request.user) 

 
 А.3 Функція розрахунку індексу AQI 
 
 
1. class LocationMonitoringDataView(viewsets.ViewSet):
2.     permission_classes = [permissions.IsAuthenticated]
3. 
4.     def list(self, request):
5.         user = request.user
6.         location_id = request.query_params.get('id')
7. 
8.         if location_id:
9.             locations = Location.objects.filter(id=location_id, user=user)
10.         else:
11.             locations = Location.objects.filter(user=user)
12.         data = []
13.         for location in locations:
14.             monitoring_data = MonitoringData.objects.filter(location=location)
15.             serialized_data = MonitoringDataSerializer(monitoring_data, many=True).data
16.             aqi = sum(item['parameter']['weight'] * item['value'] for item in serialized_data)
17.             data.append({
18.                 "id": location.id,
19.                 "monitoring_data": serialized_data,
20.                 "AQI": aqi,
21.             })
22.         return Response(data) 
 



ДОДАТОК Б 
Структура бази даних у вигляді ER-моделі даних


 
Рисунок Б.1 – Структура бази даних у вигляді ER-моделі даних



 

ДОДАТОК В
Посилання на UML діаграму прецедентів програмної системи


 

Рисунок Д.1 – UML діаграма прецедентів
 
 
ДОДАТОК Г 
Код клієнтської частини 
 
 Г.1 Сторінка реєстрації
 
 
1    1. import React, { useState } from 'react';
2. import axios from 'axios';
3. import { Link, useNavigate } from 'react-router-dom';
4. import { useTranslation } from "react-i18next";
5. 
6. function Register() {
7.     const navigate = useNavigate();
8.     const [email, setEmail] = useState('');
9.     const [username, setUsername] = useState('');
10.     const [password, setPassword] = useState('');
11.     const [confirmPassword, setConfirmPassword] = useState('');
12.     const [first_name, setFirstName] = useState('');
13.     const [last_name, setLastName] = useState('');
14.     const [gender, setGender] = useState('');
15.     const [birth_date, setBirthday] = useState('');
16.     const [error, setError] = useState(null);
17.     const { t } = useTranslation();
18. 
19.     const handleSubmit = async (e) => {
20.         e.preventDefault();
21.         if (password === confirmPassword) {
22.             try {
23.                 const response = await axios.post('http://127.0.0.1:8000/api/v1/users/', {
24.                     first_name,
25.                     last_name,
26.                     username,
27.                     email,
28.                     password,
29.                     gender,
30.                     birth_date
31.                 });
32.                 setError(null);
33.                 navigate('/login');
34.             } catch (error) {
35.                 setError(error.response ? error.response.data : 'Error: Network Error');
36.             }
37.         } else {
38.             setError('Password don’t match');
39.         }
40.     }
41. 
42.     return (
43.         <div className="login-container">
44.             <div className="login-form">
45.                 <h2 className="text-center mb-4">{t('registration')}</h2>
46.                 <form onSubmit={handleSubmit}>
47. 
48.                   <div className="row mb-3">
49.                     <div className="col">
50.                         <label htmlFor="first_name" className="form-label">{t('firstName')}</label>
51.                         <input
52.                             type="text"
53.                             className="form-control"
54.                             id="first_name"
55.                             value={first_name}
56.                             onChange={(e) => setFirstName(e.target.value)}
57.                             required
58.                         />
59.                     </div>
60.                     <div className="col">
61.                         <label htmlFor="last_name" className="form-label">{t('surname')}</label>
62.                         <input
63.                             type="text"
64.                             className="form-control"
65.                             id="last_name"
66.                             value={last_name}
67.                             onChange={(e) => setLastName(e.target.value)}
68.                             required
69.                         />
70.                     </div>
71.                   </div>
72.                     <div className="mb-3">
73.                         <label htmlFor="username" className="form-label">{t('username')}</label>
74.                         <input
75.                             type="text"
76.                             className="form-control"
77.                             id="username"
78.                             value={username}
79.                             onChange={(e) => setUsername(e.target.value)}
80.                             required
81.                         />
82.                     </div>
83.                     <div className="mb-3">
84.                         <label htmlFor="email" className="form-label">{t('email')}</label>
85.                         <input
86.                             type="text"
87.                             className="form-control"
88.                             id="email"
89.                             value={email}
90.                             onChange={(e) => setEmail(e.target.value)}
91.                             required
92.                         />
93.                     </div>
94.                     <div className="row mb-3">
95.                     <div className="col">
96.                         <label htmlFor="password" className="form-label">{t('password')}</label>
97.                         <input
98.                             type="password"
99.                             className="form-control"
100.                             id="password"
101.                             value={password}
102.                             onChange={(e) => setPassword(e.target.value)}
103.                             required
104.                         />
105.                     </div>
106.                     <div className="col">
107.                         <label htmlFor="confirmPassword" className="form-label">{t('confirmPass')}</label>
108.                         <input
109.                             type="password"
110.                             className="form-control"
111.                             id="confirmPassword"
112.                             value={confirmPassword}
113.                             onChange={(e) => setConfirmPassword(e.target.value)}
114.                             required
115.                         />
116.                     </div>
117.                     </div>
118.                     <div className="mb-3">
119.                         <label htmlFor="birth_date" className="form-label">{t('birthday')}</label>
120.                         <input
121.                             type="date"
122.                             className="form-control"
123.                             id="birth_date"
124.                             value={birth_date}
125.                             onChange={(e) => setBirthday(e.target.value)}
126.                             required
127.                         />
128.                     </div>
129.                     <div className="mb-3">
130.                         <label htmlFor="gender" className="form-label">{t('gender')}</label>
131.                         <select id="gender" className="form-control" onChange={(e) => setGender(e.target.value)}>
132.                             <option value="M">{t('male')}</option>
133.                             <option value="F">{t('female')}</option>
134.                         </select>
135.                     </div>
136. 
137.                     <button type="submit" className="btn btn-success w-100">{t('submitRegistr')}</button>
138.                 </form>
139.                 <div className="mt-3 text-center">
140.                     {t('alreadyHaveAcc')} <Link to="/login">{t('login')}</Link>
141.                 </div>
142.                 {error && (
143.                     <div className="mt-3 text-danger">
144.                         <p>{JSON.stringify(error)}</p>
145.                     </div>
146.                 )}
147.             </div>
148.         </div>
149.     );
150. }
151. 
152. export default Register; 
 
 
 Г.2 Сторінка додавання нової локації 
 
1. import React, { useEffect, useState } from 'react';
2. import axios from 'axios';
3. import { Link, useNavigate } from 'react-router-dom';
4. import "../styles/addLocation.css";
5. import { useTranslation } from "react-i18next";
6. 
7. function AddLocation() {
8.     const [name, setName] = useState("");
9.     const navigate = useNavigate();
10.     const accessToken = localStorage.getItem('accessToken');
11.     const [description, setDescription] = useState("");
12.     const [country, setCountry] = useState("");
13.     const [city, setCity] = useState("");
14.     const [choosenLocationType, setChoosenLocationType] = useState([]);
15.     const [payment_key, setPaymentKey] = useState("");
16.     const [error, setError] = useState(null);
17.     const [location_type, setLocationType] = useState("");
18.     const [isModalOpen, setIsModalOpen] = useState(false);
19.     const { t } = useTranslation();
20.     const openModal = () => setIsModalOpen(true);
21. 
22.     useEffect(() => {
23.         if (!accessToken) {
24.             navigate('/login');
25.         } else {
26.             const url = new URL(window.location.href);
27.             const key = url.href.split('/addLocation?')[1];
28. 
29.             if (key) {
30.                 setPaymentKey(key);
31.             }
32. 
33.             const fetchLocationTypes = async () => {
34.                 try {
35.                     const locationTypeResponse = await axios.get('http://127.0.0.1:8000/api/v1/locations-types/', {
36.                         headers: {
37.                             Authorization: `Bearer ${accessToken}`
38.                         }
39.                     });
40.                     setChoosenLocationType(locationTypeResponse.data);
41.                 } catch (err) {
42.                     setError(err);
43.                 }
44.             }
45.             fetchLocationTypes();
46.         }
47.     }, [accessToken, navigate]);
48. 
49.     const handleSubmit = async (e) => {
50.         e.preventDefault();
51. 
52.         try {
53.             const response = await axios.post('http://127.0.0.1:8000/api/v1/locations/', {
54.                 name,
55.                 description,
56.                 country,
57.                 city,
58.                 location_type,
59.                 payment_key
60.             }, { headers: { Authorization: `Bearer ${accessToken}` } });
61.             openModal();
62.         } catch (error) {
63.             setError(error.response ? error.response.data : 'Error: Network Error');
64.         }
65.     }
66. 
67.     return (
68.         <div className="login-container">
69.             <div className="login-form">
70.                 <h2 className="text-center mb-4">{t('addLoc')}</h2>
71.                 <form onSubmit={handleSubmit}>
72.                     <div className="mb-3">
73.                         <label htmlFor="name" className="form-label">{t('name')}</label>
74.                         <input
75.                             type="text"
76.                             className="form-control"
77.                             id="name"
78.                             value={name}
79.                             onChange={(e) => setName(e.target.value)}
80.                             required
81.                         />
82.                     </div>
83.                     <div className="mb-3">
84.                         <label htmlFor="description" className="form-label">{t('description')}</label>
85.                         <input
86.                             type="text"
87.                             className="form-control"
88.                             id="description"
89.                             value={description}
90.                             onChange={(e) => setDescription(e.target.value)}
91.                             required
92.                         />
93.                     </div>
94.                     <div className="mb-3">
95.                         <label htmlFor="country" className="form-label">{t('country')}</label>
96.                         <input
97.                             type="text"
98.                             className="form-control"
99.                             id="country"
100.                             value={country}
101.                             onChange={(e) => setCountry(e.target.value)}
102.                             required
103.                         />
104.                     </div>
105.                     <div className="mb-3">
106.                         <label htmlFor="city" className="form-label">{t('city')}</label>
107.                         <input
108.                             type="text"
109.                             className="form-control"
110.                             id="city"
111.                             value={city}
112.                             onChange={(e) => setCity(e.target.value)}
113.                             required
114.                         />
115.                     </div>
116.                     <div className="row mb-3">
117.                         <div className="col">
118.                             <label htmlFor="location_type" className="form-label">{t('locType')}</label>
119.                             <select id="location_type" className="form-control" onChange={(e) => setLocationType(e.target.value)}>
120.                                 {choosenLocationType.map(type => (
121.                                     <option key={type.id} value={type.id}>{type.name}</option>
122.                                 ))}
123.                             </select>
124.                         </div>
125.                     </div>
126.                     <button type="submit" className="btn btn-success w-100">{t('add')}</button>
127.                 </form>
128. 
129.                 {error && (
130.                     <div className="mt-3 text-danger">
131.                         <p>{JSON.stringify(error)}</p>
132.                     </div>
133.                 )}
134.                 {isModalOpen && (
135.                     <div className="modal modal-center">
136.                         <div className="modal-content">
137.                             <h1 className="modal-h1">🎉</h1>
138.                             <h2>{t('congrats')}</h2>
139.                             <p className="modal-text">{t('greetingLoc')}</p>
140.                             <Link className="modal-link" to="/dashboard">{t('great')}</Link>
141.                         </div>
142.                     </div>
143.                 )}
144. 
145.             </div>
146.         </div>
147.     );
148. }
149. 
150. export default AddLocation;
 

 Г.3 Код панелі управління адміністратора 
 
 
1. import React, { useState } from 'react';
2. import { useNavigate } from 'react-router-dom';
3. import 'bootstrap/dist/css/bootstrap.min.css';
4. import '../styles/adminDashboard.css';
5. import Users from './Users';
6. import Locations from './Locations';
7. import axios from 'axios';
8. import LanguageSwitcher from "./LanguageSwitcher";
9. import { useTranslation } from "react-i18next";

10. function AdminDashboard() {
11.     const [activeComponent, setActiveComponent] = useState('users');
12.     const navigate = useNavigate();
13.     const [backupStatus, setBackupStatus] = useState(null);
14.     const accessToken = localStorage.getItem('accessToken');
15.     const { t } = useTranslation();

16.     const renderComponent = () => {
17.         switch (activeComponent) {
18.             case 'users':
19.                 return <Users />;
20.             case 'locations':
21.                 return <Locations />;
22.             default:
23.                 return <Users />;
24.         }
25.     };

26.     const handleLogout = () => {
27.         localStorage.removeItem('accessToken');
28.         localStorage.removeItem('username');
29.         navigate('/login');
30.     };

31.     const handleBackup = async () => {
32.         try {
33.             const response = await axios.post('http://127.0.0.1:8000/api/v1/backup/', {}, {
34.                 headers: {
35.                     Authorization: `Bearer ${accessToken}`,
36.                 }
37.             });
38.             if (response.data.status === 'success') {
39.                 setBackupStatus(t('backupSuccess'));
40.             } else {
41.                 setBackupStatus(t('backupNot'));
42.             }
43.         } catch (error) {
44.             setBackupStatus(t('backupError'));
45.         }
46.     };

47.     return (
48.         <div className="container-fluid admin-dashboard">
49.             <LanguageSwitcher />
50.             <div className="row">
51.                 <nav className="col-md-2 d-none d-md-block sidebar">
52.                     <div className="sidebar-sticky">
53.                         <ul className="nav flex-column">
54.                             <div className="d-flex justify-content-between flex-wrap flex-md-nowrap align-items-center pt-3 pb-2 mb-3 border-bottom">
55.                                 <h4 className="admin-header">{t('adminDashboard')}</h4>
56.                             </div>
57.                             <li className="nav-item">
58.                                 <span
59.                                     className={`nav-link ${activeComponent === 'users' ? 'active' : ''}`}
60.                                     onClick={() => setActiveComponent('users')}
61.                                     style={{ cursor: 'pointer' }}
62.                                 >
63.                                     {t('users')}
64.                                 </span>
65.                             </li>
66.                             <li className="nav-item">
67.                                 <span
68.                                     className={`nav-link ${activeComponent === 'locations' ? 'active' : ''}`}
69.                                     onClick={() => setActiveComponent('locations')}
70.                                     style={{ cursor: 'pointer' }}
71.                                 >
72.                                     {t('locations')}
73.                                 </span>
74.                             </li>
75.                             <li className="nav-item">
76.                                 <div className="admin-backup-btn-container">
77.                                     <button
78.                                         className="admin-backup-btn"
79.                                         onClick={handleBackup}
80.                                     >
81.                                         {t('createBckup')}
82.                                     </button>
83.                                 </div>
84.                             </li>
85.                             <li className="nav-item">
86.                                 <a className="btn-dashboard btn-outline-danger admin-btn" onClick={handleLogout}>
87.                                     {t('logout')}
88.                                 </a>
89.                             </li>
90.                         </ul>
91.                     </div>
92.                 </nav>

93.                 <main role="main" className="col-md-9 ml-sm-auto col-lg-10 px-4">
94.                     {renderComponent()}
95.                     {backupStatus && <div className="alert alert-info mt-3">{backupStatus}</div>}
96.                 </main>
97.             </div>
98.         </div>
99.     );
100. }

101. export default AdminDashboard;
 
 
 
ДОДАТОК Д 
Перевірка на плагіат

